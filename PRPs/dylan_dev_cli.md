name: "Dylan Dev CLI Implementation"
description: |
A new command for the Dylan CLI that automates the implementation of fixes based on code reviews generated by the dylan review command.

## Goal

Create a new `dylan dev` command that automatically implements fixes for issues identified by the `dylan review` command, prioritizing critical and high-severity issues, and integrates seamlessly with the existing Dylan CLI workflow.

## Why

- **Efficiency**: Automates the manual process of fixing issues identified in code reviews, saving developer time
- **Consistency**: Ensures that fixes follow best practices and coding standards consistently
- **Completion**: Completes the review â†’ dev â†’ PR workflow, providing a comprehensive solution for code quality improvement
- **Quality**: Implements changes in a structured, methodical way, reducing the chance of introducing new issues
- **Documentation**: Provides detailed reports on what changes were made and why, improving transparency and knowledge sharing
- **Integration**: Integrates seamlessly with the existing Dylan CLI workflow
- **Flexibility**: Allows for customizing the fix implementation process

## What

The `dylan dev` command will:

- Accept a review file generated by `dylan review` as input
- Parse the review file to identify issues by severity
- Leverage Claude Code to implement fixes for issues, prioritizing critical and high-severity issues
- Apply fixes to the current branch or a designated branch
- Generate a development report detailing changes made
- Support various options for controlling the fix implementation process
- Integrate with the existing Dylan CLI architecture and UI components

## Endpoints/APIs to Implement

N/A - This feature implements a CLI command, not an API endpoint.

## Current Directory Structure

```
dylan/
â”œâ”€â”€ cli.py                                # Main CLI entry point
â”œâ”€â”€ utility_library/
â”‚   â”œâ”€â”€ dylan_review/                     # Review functionality
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ dylan_review_cli.py           # Review CLI interface
â”‚   â”‚   â””â”€â”€ dylan_review_runner.py        # Review core functionality
â”‚   â”œâ”€â”€ dylan_pr/                         # PR functionality
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ dylan_pr_cli.py               # PR CLI interface
â”‚   â”‚   â””â”€â”€ dylan_pr_runner.py            # PR core functionality
â”‚   â”œâ”€â”€ provider_clis/                    # Provider interfaces
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ provider_claude_code.py       # Claude Code provider
â”‚   â”‚   â””â”€â”€ shared/
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â””â”€â”€ subprocess_utils.py       # Subprocess utilities
â”‚   â””â”€â”€ shared/                           # Shared utilities and UI components
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ config.py                     # Configuration
â”‚       â”œâ”€â”€ error_handling.py             # Error handling
â”‚       â”œâ”€â”€ exit_command.py               # Exit command handling
â”‚       â”œâ”€â”€ progress.py                   # Progress reporting
â”‚       â””â”€â”€ ui_theme.py                   # UI theme components
```

## Proposed Directory Structure

```
dylan/
â”œâ”€â”€ cli.py                                # Updated to add dev command
â”œâ”€â”€ utility_library/
â”‚   â”œâ”€â”€ dylan_review/                     # Existing review functionality
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ dylan_review_cli.py
â”‚   â”‚   â””â”€â”€ dylan_review_runner.py
â”‚   â”œâ”€â”€ dylan_dev/                        # New dev functionality
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ dylan_dev_cli.py              # Dev CLI interface
â”‚   â”‚   â””â”€â”€ dylan_dev_runner.py           # Dev core functionality
â”‚   â”œâ”€â”€ dylan_pr/                         # Existing PR functionality
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ dylan_pr_cli.py
â”‚   â”‚   â””â”€â”€ dylan_pr_runner.py
â”‚   â””â”€â”€ ... (other existing directories)
```

## Files to Reference

- `/Users/rasmus/Projects/claudecode-utility/concept_library/simple_dev/simple_dev_poc.py` (read_only) Reference implementation of the dev concept
- `/Users/rasmus/Projects/claudecode-utility/dylan/utility_library/dylan_review/dylan_review_cli.py` (read_only) Pattern for CLI interface implementation
- `/Users/rasmus/Projects/claudecode-utility/dylan/utility_library/dylan_review/dylan_review_runner.py` (read_only) Pattern for runner implementation
- `/Users/rasmus/Projects/claudecode-utility/dylan/utility_library/provider_clis/provider_claude_code.py` (read_only) Provider interface for Claude Code
- `/Users/rasmus/Projects/claudecode-utility/dylan/cli.py` (read_only) Main CLI entry point to be updated
- `/Users/rasmus/Projects/claudecode-utility/dylan/utility_library/shared/ui_theme.py` (read_only) UI theme components for consistent look and feel
- https://typer.tiangolo.com/tutorial/ (read_only) Documentation for Typer CLI library used in the project

## Files to Implement (concept)

### Core CLI Module

1. `dylan/utility_library/dylan_dev/__init__.py` - Empty init file for the package

```python
"""Dylan Development module for implementing fixes from code reviews."""
```

2. `dylan/utility_library/dylan_dev/dylan_dev_cli.py` - CLI interface for the dev command

```python
#!/usr/bin/env python3
"""CLI interface for the Claude Code development runner using Typer."""

import typer
from rich.console import Console

from ..shared.ui_theme import (
    create_box_header,
    create_header,
    format_boolean_option,
)
from .dylan_dev_runner import generate_dev_prompt, run_claude_dev

console = Console()


def dev(
    review_file: str = typer.Argument(
        ...,
        help="Path to the review file to use as input (review file must be provided with relative path)",
        metavar="REVIEW_FILE",
    ),
    branch: str | None = typer.Option(
        None,
        "--branch",
        "-b",
        help="Branch to apply fixes to (defaults to creating a new branch from the current branch name: fix-dylan-review-<target-branch>)",
        show_default=True,
    ),
    output: str | None = typer.Option(
        None,
        "--output",
        "-o",
        help="Custom output file path for dev report (defaults to tmp/dylan-dev-report-<branch>.md)",
        show_default=True,
    ),
    tasks: str | None = typer.Option(
        None,
        "--tasks",
        "-t",
        help="Specify task numbers from the review file to fix (default: all tasks) (comma-separated task numbers 001, 002)",
        show_default=True,
    ),
    priority: str = typer.Option(
        "critical,high",
        "--priority",
        "-p",
        help="Only fix issues with specified priority (default: high and critical) (comma-separated: critical, high, medium, low)",
        show_default=True,
    ),
    interactive: bool = typer.Option(
        False,
        "--interactive",
        "-i",
        help="Run in interactive mode, asking for confirmation before implementing each fix",
        show_default=True,
    ),
    dry_run: bool = typer.Option(
        False,
        "--dry-run",
        help="Preview changes without applying them to files",
        show_default=True,
    ),
    debug: bool = typer.Option(
        False,
        "--debug",
        "-d",
        help="Print debug information (including the full prompt)",
        show_default=True,
    ),
):
    """Implement fixes from code reviews using Claude Code.

    Takes a review file generated by 'dylan review' and implements fixes
    for issues based on priority. Generates a development report detailing
    changes made.

    Examples:
        # Implement fixes from a review file
        dylan dev tmp/dylan-review-compare-feature-branch-to-develop.md

        # Implement fixes on a specific branch
        dylan dev tmp/dylan-review-compare-feature-branch-to-develop.md --branch feature-branch

        # Only fix critical issues
        dylan dev tmp/dylan-review-compare-feature-branch-to-develop.md --priority critical

        # Only fix issues in specific tasks
        dylan dev tmp/dylan-review-compare-feature-branch-to-develop.md --tasks "001, 002" (accepts critical, high, medium, low or comma-separated task numbers)

        # Run in headless mode (interactive is default)
        dylan dev tmp/dylan-review-compare-feature-branch-to-develop.md --headless

        # Preview changes without applying them
        dylan dev tmp/dylan-review-compare-feature-branch-to-develop.md --dry-run
    """
    # Default values
    allowed_tools = ["Read", "Glob", "Grep", "LS", "Bash", "Edit", "MultiEdit", "Write", "TodoRead", "TodoWrite"]
    output_format = "text"

    # Show header with flair
    console.print()
    console.print(create_header("Dylan", "Dev"))
    console.print()

    # Process priority list
    priority_list = [p.strip().lower() for p in priority.split(",")]

    # Show development configuration
    console.print(create_box_header("Development Configuration", {
        "Review File": review_file,
        "Branch": branch or "current branch",
        "Output": output or "tmp/dylan-dev-report-<branch>.md",
        "Priority": ", ".join(priority_list).title(),
        "Target Tasks": tasks or "All tasks",
        "Mode": "ðŸ” Dry run" if dry_run else "ðŸ’» Live run",
        "Interactive": format_boolean_option(interactive, "âœ“ Enabled", "âœ— Disabled"),
        "Debug": format_boolean_option(debug, "âœ“ Enabled", "âœ— Disabled"),
        "Exit": "Ctrl+C to interrupt"
    }))
    console.print()

    # Generate prompt
    prompt = generate_dev_prompt(
        review_file=review_file,
        branch=branch,
        target=tasks,
        priorities=priority_list,
        interactive=interactive,
        dry_run=dry_run,
        output_file=output,
        output_format=output_format,
    )

    # Run development process
    run_claude_dev(
        prompt,
        allowed_tools=allowed_tools,
        output_format=output_format,
        debug=debug,
    )


# For backwards compatibility and standalone usage
def main():
    """Entry point for standalone CLI usage."""
    typer.run(dev)


if __name__ == "__main__":
    main()
```

3. `dylan/utility_library/dylan_dev/dylan_dev_runner.py` - Core implementation of the dev command

```python
#!/usr/bin/env python3
"""Core functionality for the Claude Code development runner.

This module provides the functionality to parse review files and implement fixes
based on the issues identified, prioritizing critical and high-severity issues.

Python API usage:
    from dylan.utility_library.dylan_dev.dylan_dev_runner import run_claude_dev, generate_dev_prompt

    # Generate prompt from review file
    prompt = generate_dev_prompt(review_file="tmp/review.md")

    # Run development process
    run_claude_dev(prompt)
"""

import os
import sys
from pathlib import Path
from typing import Literal, List

from rich.console import Console

from ..provider_clis.provider_claude_code import get_provider
from ..shared.config import (
    CLAUDE_CODE_NPM_PACKAGE,
    CLAUDE_CODE_REPO_URL,
    GITHUB_ISSUES_URL,
)
from ..shared.progress import create_dylan_progress, create_task_with_dylan
from ..shared.ui_theme import ARROW, COLORS, SPARK, create_status

console = Console()


def run_claude_dev(
    prompt: str,
    allowed_tools: list[str] | None = None,
    branch: str | None = None,
    output_format: Literal["text", "json", "stream-json"] = "text",
    debug: bool = False,
) -> None:
    """Run Claude Code with a development prompt and specified tools.

    Args:
        prompt: The development prompt to send to Claude
        allowed_tools: List of allowed tools (defaults to Read, Glob, Grep, LS, Bash, Write, Edit, MultiEdit)
        branch: Optional branch to apply fixes to (not used in this implementation)
        output_format: Output format (text, json, stream-json)
        debug: Whether to print debug information (default False)
    """
    # Default safe tools for development
    if allowed_tools is None:
        allowed_tools = ["Read", "Glob", "Grep", "LS", "Bash", "Write", "Edit", "MultiEdit", "TodoRead", "TodoWrite"]

    # Print prompt for debugging
    if debug:
        print("\n===== DEBUG: PROMPT =====\n")
        print(prompt)
        print("\n========================\n")

    # We no longer provide a fixed output file - Claude will determine the correct filename
    # based on the review file and branch
    output_file = None

    # Get provider and run the development process
    provider = get_provider()

    with create_dylan_progress(console=console) as progress:
        # Start the development task
        task = create_task_with_dylan(progress, "Dylan is implementing fixes...")

        try:
            result = provider.generate(
                prompt,
                output_path=output_file,
                allowed_tools=allowed_tools,
                output_format=output_format,
            )

            # Update task to complete
            progress.update(task, completed=True)

            # Success message with flair
            console.print()
            console.print(create_status("Development completed successfully!", "success"))
            console.print(f"[{COLORS['muted']}]Report saved to tmp/ directory[/]")
            console.print()

            # Show a nice completion message
            console.print(f"[{COLORS['primary']}]{ARROW}[/] [bold]Development Summary[/bold] [{COLORS['accent']}]{SPARK}[/]")
            console.print(f"[{COLORS['muted']}]Dylan has implemented fixes based on the review and generated a detailed report.[/]")
            console.print()

            if result and "Mock" not in result:  # Don't show mock results
                console.print(result)
        except RuntimeError as e:
            progress.update(task, completed=True)
            console.print()
            console.print(create_status(str(e), "error"))
            sys.exit(1)
        except FileNotFoundError:
            progress.update(task, completed=True)
            console.print()
            console.print(create_status("Claude Code not found!", "error"))
            console.print(f"\n[{COLORS['warning']}]Please install Claude Code:[/]")
            console.print(f"[{COLORS['muted']}]  npm install -g {CLAUDE_CODE_NPM_PACKAGE}[/]")
            console.print(f"\n[{COLORS['muted']}]For more info: {CLAUDE_CODE_REPO_URL}[/]")
            sys.exit(1)
        except Exception as e:
            progress.update(task, completed=True)
            console.print()
            console.print(create_status(f"Unexpected error: {e}", "error"))
            console.print(f"\n[{COLORS['muted']}]Please report this issue at:[/]")
            console.print(f"[{COLORS['primary']}]{GITHUB_ISSUES_URL}[/]")
            sys.exit(1)


def generate_dev_prompt(
    review_file: str,
    branch: str | None = None,
    target: str | None = None,
    priorities: List[str] = None,
    interactive: bool = False,
    dry_run: bool = False,
    output_file: str | None = None,
    output_format: str = "text",
) -> str:
    """Generate a development prompt based on a review file.

    Args:
        review_file: Path to the review file
        branch: Optional branch to apply fixes to
        target: Optional glob pattern to filter files
        priorities: List of priorities to fix (critical, high, medium, low)
        interactive: Whether to run in interactive mode
        dry_run: Whether to preview changes without applying them
        output_file: Optional custom output file path
        output_format: Output format (text, json, stream-json)

    Returns:
        The development prompt string
    """
    # Ensure review file exists
    if not os.path.exists(review_file):
        raise FileNotFoundError(f"Review file not found: {review_file}")

    # Set default priorities if not provided
    if priorities is None:
        priorities = ["critical", "high"]

    # Determine file extension based on format
    extension = ".json" if output_format == "json" else ".md"

    # Build the prompt with detailed instructions
    branching_instructions = """
BRANCH HANDLING:
1. If a specific branch was provided, switch to that branch: git checkout <branch>
2. If no branch was provided, get the current branch: git symbolic-ref --short HEAD
3. Store the branch name for use in the report and output file name
4. Ensure the tmp/ directory exists: mkdir -p tmp
"""

    file_handling_instructions = f"""
FILE HANDLING INSTRUCTIONS:
1. Create the tmp/ directory if it doesn't exist: mkdir -p tmp
2. Determine the current branch if not specified
3. Create a filename in this format: tmp/dylan-dev-report-<branch>{extension}
   - Replace any slashes in branch names with hyphens (e.g., feature/foo becomes feature-foo)
   - DO NOT add timestamps to the filename itself
4. If the file already exists:
   - Read the existing file to understand previous development reports
   - APPEND to the existing file with a clear separator
   - Add a timestamp header: ## Development [DATE] [TIME]
   - This allows tracking multiple development runs over time
"""

    review_parsing_instructions = f"""
REVIEW PARSING INSTRUCTIONS:
1. Read and parse the review file: {review_file}
2. Identify all issues from the review, focusing on:
   - Issue ID
   - Severity (critical, high, medium, low)
   - Affected files
   - Description
   - Suggested fixes
3. Filter issues based on provided criteria:
   - Only include issues with priorities: {", ".join(priorities)}
   - If target files are specified, only include issues affecting those files
4. Sort issues by severity (critical first, then high, etc.)
5. Create a plan to implement fixes for each selected issue
"""

    implementation_instructions = f"""
IMPLEMENTATION INSTRUCTIONS:
1. For each issue to fix:
   - Review the issue details and suggested fixes
   - Create a plan for implementing the fix
   - {"Show the plan and ask for confirmation before proceeding" if interactive else "Proceed with the implementation"}
   - {"Explain what changes would be made without modifying files" if dry_run else "Make the necessary changes to fix the issue"}
   - Run tests if available to verify the fix works
   - Document what was done and why
2. After all fixes are implemented:
   - Run linting and type checking if available
   - Verify all tests pass
   - Document any issues that couldn't be fixed
"""

    formatting_instructions = f"""
REPORT FORMATTING INSTRUCTIONS:
1. Generate a detailed development report with:
   - Summary of what was fixed
   - List of issues fixed, organized by severity
   - For each issue:
     - Issue ID and description
     - Files modified
     - Changes made
     - Test results
   - List of issues not fixed (if any) and why
   - Next steps or recommendations
2. Save the report to: tmp/dylan-dev-report-<branch>{extension}
3. Display a summary of the changes made
"""

    return f"""
Implement fixes for issues identified in the code review.

{branching_instructions}

{file_handling_instructions}

{review_parsing_instructions}

{implementation_instructions}

{formatting_instructions}

INPUT PARAMETERS:
- Review file: {review_file}
- Branch: {branch or "current branch"}
- Target files: {target or "All files"}
- Priorities: {", ".join(priorities)}
- Mode: {"Dry run (preview only)" if dry_run else "Live run (apply changes)"}
- Interactive: {"Yes" if interactive else "No"}
- Custom output file: {output_file or "None (use default)"}

IMPLEMENTATION APPROACH:
1. First read and understand the review file to identify issues
2. Create a plan for fixing each issue
3. {"Preview changes without applying them" if dry_run else "Implement fixes one by one"}
4. Generate a detailed report of what was done
5. If any tests fail after fixes, revert the changes and document the issues

**IMPORTANT INSTRUCTIONS:**
- Always ensure code changes follow the existing patterns and styles
- {"Do not modify any files, only show what would be changed" if dry_run else "Apply changes carefully, preserving code style and formatting"}
- Include a "Steps Executed" section listing all commands and decisions you made
- Use the exact filename format: tmp/dylan-dev-report-<branch>{extension}
- If you encounter any errors, document them clearly in the report
"""


def determine_report_filename(branch: str | None = None, output_format: str = "text") -> str:
    """Determine the correct report filename based on branch and format.

    Args:
        branch: Branch name (if None, will use current branch)
        output_format: Output format (text, json, stream-json)

    Returns:
        The determined filename
    """
    extension = ".json" if output_format == "json" else ".md"

    # Get current branch if not specified
    if branch is None:
        try:
            import subprocess
            result = subprocess.run(
                ["git", "symbolic-ref", "--short", "HEAD"],
                capture_output=True,
                text=True,
                check=True,
            )
            branch = result.stdout.strip()
        except (subprocess.SubprocessError, FileNotFoundError):
            branch = "unknown-branch"

    # Sanitize branch name for filename
    branch_filename = branch.replace("/", "-")

    # Ensure tmp directory exists
    os.makedirs("tmp", exist_ok=True)

    return f"tmp/dylan-dev-report-{branch_filename}{extension}"
```

### CLI Entry Point Update

4. `dylan/cli.py` - Updated to add the dev command

```python
"""Root Typer application that dispatches to vertical slices.

Includes 'standup', 'review', 'dev', 'pr', and 'release' commands.
"""

import typer
from rich.console import Console
from rich.table import Table

from .utility_library.dylan_dev.dylan_dev_cli import dev
from .utility_library.dylan_pr.dylan_pr_cli import pr
from .utility_library.dylan_release.dylan_release_cli import release_app
from .utility_library.dylan_review.dylan_review_cli import review
from .utility_library.dylan_standup.standup_typer import standup_app
from .utility_library.shared.ui_theme import ARROW, COLORS, SPARK

console = Console()

app = typer.Typer(
    help=f"[{COLORS['primary']}]Dylan[/] [{COLORS['accent']}]{SPARK}[/] AI-powered development utilities",
    add_completion=False,
    no_args_is_help=False,
    pretty_exceptions_show_locals=False,
    rich_markup_mode="rich",
)
app.add_typer(standup_app, name="standup", help="Generate daily standup reports from git activity")
app.add_typer(release_app, name="release", help="Create and manage project releases")
app.command(name="review", help="Run AI-powered code reviews on git branches")(review)
app.command(name="dev", help="Implement fixes from code reviews")(dev)
app.command(name="pr", help="Create pull requests with AI-generated descriptions")(pr)


@app.callback(invoke_without_command=True)
def _main(ctx: typer.Context) -> None:
    """Show welcome message when no command is provided."""
    if ctx.invoked_subcommand is None:
        # Welcome header with flair
        console.print(f"\n[{COLORS['primary']}]{ARROW}[/] [bold]Dylan[/bold] [{COLORS['accent']}]{SPARK}[/]")
        console.print("[dim]AI-powered development utilities using Claude Code[/dim]\n")

        # Commands table with custom styling
        table = Table(
            show_header=True,
            header_style=f"bold {COLORS['primary']}",
            border_style=COLORS['muted'],
            title_style=f"bold {COLORS['accent']}",
            box=None,
        )

        table.add_column("Command", style=COLORS['secondary'], width=12)
        table.add_column("Description", style=COLORS['primary'])
        table.add_column("Example", style="dim")

        table.add_row(
            "standup",
            "Generate daily standup reports",
            "dylan standup --since yesterday"
        )
        table.add_row(
            "review",
            "Run code reviews on branches",
            "dylan review feature-branch"
        )
        table.add_row(
            "dev",
            "Implement fixes from reviews",
            "dylan dev tmp/review.md"
        )
        table.add_row(
            "pr",
            "Create pull requests",
            "dylan pr --target develop"
        )
        table.add_row(
            "release",
            "Manage project releases",
            "dylan release --minor --tag"
        )

        console.print(table)
        help_text = f"\n[{COLORS['muted']}]Use[/] [{COLORS['primary']}]dylan <command> --help[/]"
        console.print(f"{help_text} [{COLORS['muted']}]for detailed options[/]")
        console.print("[dim]Example: dylan review --help[/dim]\n")
```

## Implementation Notes

### CLI Integration

- The implementation follows the same pattern as the existing `review` and `pr` commands, maintaining consistency in the UI and user experience
- The command is implemented as a module with CLI interface and runner components, following the established pattern
- Typer is used for the CLI interface, with rich markdown for styling and UI components

### Development Process

- The implementation follows a structured approach:
  1. Parse the review file to identify issues
  2. Filter issues based on priority and target files
  3. Implement fixes for each issue, starting with critical issues
  4. Generate a development report detailing the changes made
- The process can be run in interactive mode, where the user is asked for confirmation before each change
- The process can also be run in dry-run mode, where changes are previewed but not applied

### Safety Measures

- Error handling is implemented at all stages of the process
- The tool should check for the existence of the review file before proceeding
- Changes should be carefully applied, preserving code style and formatting

## Validation Gates

1. **Functionality Requirements**

   - The command must be accessible via `dylan dev <review_file>`
   - The Prompt instructs claude code to read the entire review file and implement fixes for issues based on priority
   - The command must generate a development report
   - The command must support all specified options

2. **Integration Requirements**

   - The command must integrate with the existing Dylan CLI
   - The command must follow the same UI patterns as other commands
   - The command must use the provider interface for Claude Code

3. **Quality Requirements**

   - All code must pass linting and type checking
   - All code must have appropriate error handling
   - All code must follow the project's coding standards
   - The command must provide clear feedback to the user

4. **Testing Requirements**
   - Unit tests must be implemented for core functionality
   - Integration tests must be implemented for the complete workflow
   - Edge cases must be tested (e.g., empty review files, invalid options)

## Implementation Checkpoints/Testing

### 1. CLI Interface Implementation

- Implement the CLI interface in `dylan_dev_cli.py`
- Test the interface by running `python -m dylan.utility_library.dylan_dev.dylan_dev_cli --help`
- Ensure all options are correctly defined and help text is appropriate
- Verify the interface is correctly integrated with the main CLI

### 2. Core Functionality Implementation

- Implement the core functionality in `dylan_dev_runner.py`
- Test with a sample review file
- Verify that issues are correctly parsed and filtered
- Verify that fixes are implemented correctly
- Verify that the development report is generated correctly

### 3. End-to-End Testing

- Create a test review file with various issues
- Run the command with different options
- Verify that all options work as expected
- Verify that the complete workflow (review â†’ dev â†’ pr) works correctly

## Other Considerations

### Security

- The command should not run arbitrary code from the review file
- The command should validate all inputs before processing
- The command should not make external API calls unless explicitly authorized

### Performance

- The command should be efficient, even with large review files
- The command should provide progress feedback for long-running operations
- The command should handle timeouts and interruptions gracefully

### Future Extensions

- Support for custom fix templates
- Integration with CI/CD pipelines
- Support for other review formats
- Support for other AI providers besides Claude Code
- Automatic test generation for implemented fixes

### Dependencies

- Typer for CLI interface
- Rich for UI components
- Claude Code for fix implementation
- Git for branch management

---

## GitHub Actions Integration

For the GitHub Actions integration, a sample workflow file can be created in `.github/workflows/dylan_workflow.yml` to demonstrate the automated review and fix process:

```yaml
name: Dylan Review and Dev Workflow

on:
  pull_request:
    types: [opened, synchronize]
  workflow_dispatch:

jobs:
  review-and-fix:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: |
          pip install uv
          uv venv
          source .venv/bin/activate
          uv pip install -e .
          npm install -g @anthropic-ai/claude-code

      - name: Run code review
        env:
          CLAUDE_API_KEY: ${{ secrets.CLAUDE_API_KEY }}
        run: |
          source .venv/bin/activate
          dylan review ${{ github.head_ref }} --output tmp/dylan-review.md

      - name: Implement fixes
        env:
          CLAUDE_API_KEY: ${{ secrets.CLAUDE_API_KEY }}
        run: |
          source .venv/bin/activate
          dylan dev tmp/dylan-review.md --priority critical --dry-run

      - name: Upload reports as artifacts
        uses: actions/upload-artifact@v3
        with:
          name: dylan-reports
          path: tmp/*.md
```

This workflow file demonstrates how the review and dev commands can be used together in a GitHub Actions workflow to automatically review code and propose fixes.
